Needed to understand few finance jargons like OrderBook, Trades, Markets (like BTC-USDC, one of them is base asset which is what we are giving to buy the other asset which is quote asset). The need of a time-series db. 
Market Order: just telling that I am willing to give you this much amnt of money, what might happen is exactly at that momnet, all the cheaper asks are gone and now since higher asks are there, earlier when you could have gotten like 10 SOL, now you will get 8 SOL, so the exchnage will automatcally analyzing the current orderbook, create a limit on your order above which you wont be buying a single SOL, and kind of estimates, how many SOL will should you be getting, effectively converting it to a limit order. 
The above functionality is the exact reason of /quote endpoint which "quotes" a value(roughly average as per current trades) for a single unit of asset like SOL. 

Fairly simple idea is to decribe the orderbook using the queue as it HAS to be as quick aas possible, so cant use the traditional DB approach as that will take sometime and people will lose money, so the workaround is either creater an in-memory variable(stateful), thatst the fastest but what if server dies or smth, so a queue is also maintained, which will the source of truth. 

With some brain-storming and looking here and there, got a workflow. An odd thing I realized was that the API server and the OrderBook are cnnected by a redis queue, and the user shouldnt be hitting the orderbook directly for security reasons, thats is why a separate queue in between 

The real-time part would be current price(latest price with which trade hpnd), recent trades, orderbook, time-graph

Writing to a database is slow. Your engine needs to be fast. By just firing off a message to Redis, the engine can move on to the next trade immediately, trusting another process to handle the slow task of saving the trade details to a permanent database (like PostgreSQL).

in the client-realtime, the marlet bar is gettign changed realtime with the help of websocket, the flow is likeThe MatketBar gets mounted on the screen, and du to useEffect, it sends message to the wsclient which puts it in buffered messages(concept imp if by then the ws connection is not yet done), with the SUBSCRIBE method and the right params(finally decided, that once the page mounts for a particuular symbol, subscribe to trades,book,ticker all three, as these apis, have subscribe/unsubscribe limit), and also we register with the 24hrTicker type with a callback which will set the NEW TICKER which gets refected on the frontend ui, and once we subscribe to the ticker of the right market, we get messages on ws with a specific format (found using binance docs), and with some array manipulatioon, matching the types, trigger the callback with the new ticker object(which we create using the data that we receive from the websocket which are the new prices)
When the market bar gets unmounted, which will be when i chnage  the symbol, I unsubscribe all the 3 params

MAKER: the guy who is already sitting on the orderbook
TAKER: the guy who initiated the trade, the new person
so in a buy order, the maker is the person who is selling, whereas in the sell order, the maker is the guy who is buying

workflow:::
1. Browser
The client-side (traderâ€™s web app).
Users place orders from here (e.g., buy/sell SOL/USDC).
It communicates with two backend entry points:
REST API â†’ for actions like creating orders, canceling orders.
WebSocket â†’ for real-time updates (orderbook, trades, ticker).

2. API
This is the gateway for requests (e.g., POST /api/v1/order).
When an order is submitted:
It validates request basics (auth, signature, user ID)
Sends the order into a Redis queue â†’ ensures orders are processed sequentially by the Engine
Publishes into Redis PubSub so that the frontend gets a quick confirmation (e.g., â€œOrder Accepted, ExecutedQuantity=0â€)
This is necessary because the Engine might take time to fully process, but the user shouldnâ€™t wait forever.

ğŸ‘‰ Why both Queue and PubSub?
Queue â†’ reliable, ordered processing (used by Engine)
PubSub â†’ immediate notification to interested parties (used by Browser/WebSocket)

3. Redis Queue

Acts as a task pipeline
API puts new order requests here
The Engine consumes them one by one (so orders are processed in strict sequence)
Guarantees no race conditions like â€œtwo trades modifying balances at the same time.

4. Engine
The core brain of the exchange.

Responsibilities:
Match orders (buy/sell)
Maintain orderbook state
Check user balances, lock funds
Generate trades (fills)
Emit events when something happens.

Outputs:
Publishes events back via Redis PubSub:
trade@SOL_USDC â†’ trade happened
ticker@SOL_USDC â†’ price/ticker update
depth@SOL_USDC â†’ orderbook snapshot change
Pushes trade data into a Redis Queue for the Database processor (to store OHLC/Klines)

ğŸ‘‰ This dual output separates:
Frontend real-time updates (PubSub â†’ WebSockets)
Historical persistence (Queue â†’ Database processor)

5. Redis PubSub (Engine â†’ Browser/WebSocket)
Carries real-time market events:
New trades
Updated orderbook
Updated ticker (last price, volume, etc.)
WebSocket server consumes this and pushes to users

6. WebSocket
Delivers live updates to Browser clients
Subscribed topics: trade@SOL_USDC, ticker@SOL_USDC, depth@SOL_USDC
So, whenever Engine publishes, users see updates instantly (like Binance)

7. Redis Queue (Engine â†’ Database processor)

Ensures reliable persistence of executed trades.

Example payload:
trade_created
price: 200.1
quantity: 5

Goes into DB processor so you donâ€™t lose trades if system crashes.

8. Database Processor:
Consumes trade events from queue.
Writes them into a Time-series Database.
Purpose: Generate historical data (klines, candles, charts).
Stores things like:
price: 200.1
timestamp: 123
quantity: 5

9. Time-Series DB
Specialized DB (e.g., InfluxDB, TimescaleDB, ClickHouse).
Optimized for queries like:
â€œGive me last 24h of SOL/USDC trades.â€
â€œConstruct 1m, 5m, 1h candles.â€
This is essential for charting, analytics, and price history.



Putting it all together (Flow Example):
-- User places an order
-- Browser â†’ POST /api/v1/order.

API:
-- Validates request.
-- Pushes order into Redis Queue (for Engine).
-- Publishes acknowledgment via PubSub (executedQuantity: 0, fills: []).
-- Browser immediately sees response (â€œOrder acceptedâ€).
-- Engine processes order
-- Engine reads from Redis Queue:
-- Matches order against orderbook.
-- Locks balances, executes trade.
-- Publishes trade + ticker + depth updates (PubSub).
-- Pushes trade record into Redis Queue (for DB).
-- Users get live updates

WebSocket (subscribed to PubSub) pushes updates:
-- Trade happened at 200.1.
-- Depth/orderbook updated.
-- Ticker price changed.

Persistence:
-- Database processor consumes Redis Queue events.
-- Saves trade into Time-series DB.
-- Later, users can query chart data.

Why every piece is necessary???
-- API â†’ entry point for user actions.
-- Redis Queue (API â†’ Engine) â†’ ensures sequential, reliable execution.
-- Engine â†’ core logic, does heavy lifting.
-- Redis PubSub (Engine â†’ Browser) â†’ instant frontend updates.
-- Redis Queue (Engine â†’ DB) â†’ ensures no trade data is lost, processed reliably.
-- Database Processor â†’ offloads DB writes from Engine.
-- Time-Series DB â†’ efficient storage for market data.

ğŸ‘‰ The two PubSubs you werenâ€™t sure about:
-- One is from API â†’ Browser (so users get immediate acknowledgment their order is accepted).
-- One is from Engine â†’ WebSocket â†’ Browser (for live market data: trades, ticker, depth).